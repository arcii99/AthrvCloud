//FormAI DATASET v1.0 Category: Procedurally Generated Maze ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define NUM_THREADS 4
#define MAX_ROWS 10
#define MAX_COLS 10

int maze[MAX_ROWS][MAX_COLS] = {0}; // Initialize maze to all 0's

// Generate random number between min and max, inclusive
int randNum(int min, int max) {
    return (rand() % (max - min + 1)) + min;
}

// Check if row and col are within the maze bounds
int isValid(int row, int col) {
    return (row >= 0 && row < MAX_ROWS && col >= 0 && col < MAX_COLS);
}

// Recursive function to generate maze
void generateMaze(int row, int col) {
    maze[row][col] = 1; // Mark current cell as visited

    // Get random direction to move in
    int dir = randNum(0, 3);

    // Move up
    if (dir == 0 && isValid(row - 1, col) && maze[row - 1][col] == 0) {
        maze[row - 1][col] = 1;
        generateMaze(row - 1, col);
    }
    // Move right
    else if (dir == 1 && isValid(row, col + 1) && maze[row][col + 1] == 0) {
        maze[row][col + 1] = 1;
        generateMaze(row, col + 1);
    }
    // Move down
    else if (dir == 2 && isValid(row + 1, col) && maze[row + 1][col] == 0) {
        maze[row + 1][col] = 1;
        generateMaze(row + 1, col);
    }
    // Move left
    else if (dir == 3 && isValid(row, col - 1) && maze[row][col - 1] == 0) {
        maze[row][col - 1] = 1;
        generateMaze(row, col - 1);
    }
}

// Print maze
void printMaze() {
    int i, j;
    for (i = 0; i < MAX_ROWS; i++) {
        for (j = 0; j < MAX_COLS; j++) {
            if (maze[i][j] == 0) {
                printf("#");
            } else {
                printf(" ");
            }
        }
        printf("\n");
    }
}

// Thread function
void *threadFunc(void *threadIdPtr) {
    int threadId = *(int*)threadIdPtr;
    int row, col;

    // Generate start and end points for thread
    if (threadId == 0) {
        row = 0;
        col = 0;
    } else if (threadId == 1) {
        row = 0;
        col = MAX_COLS - 1;
    } else if (threadId == 2) {
        row = MAX_ROWS - 1;
        col = 0;
    } else if (threadId == 3) {
        row = MAX_ROWS - 1;
        col = MAX_COLS - 1;
    }

    generateMaze(row, col);
    printf("Maze generated by thread %d:\n", threadId);
    printMaze();
    printf("\n");

    pthread_exit(NULL);
}

int main() {
    int i;
    pthread_t threads[NUM_THREADS];
    int threadIds[NUM_THREADS];

    // Seed random number generator
    srand(time(NULL));

    // Initialize thread Ids
    for (i = 0; i < NUM_THREADS; i++) {
        threadIds[i] = i;
    }

    // Create threads
    for (i = 0; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, threadFunc, (void*) &threadIds[i]);
    }

    // Wait for threads to finish
    for (i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}